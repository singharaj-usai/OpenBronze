return function(_p)
	local Utilities = _p.Utilities
	local create = Utilities.Create
	local write = Utilities.Write

	local battleRQgui, rqListGui, rqButton, globalError, hostGui, specGui
	local network = _p.Network
	--local groupFunction = _p.storage.Remote.PVPGroupFunction -- migrate
	local accepting
	local errorThread
	local settings = {
		forcedLevel = 50,
		location = 'Random',
		teamPreviewEnabled = true,
		isRanked = true,
	}
	local settings2v2 = {
		forcedLevel = 50,
		teamPreviewEnabled = true,
		inviteOnly = false,
	}
	local requests = {
		--	{fromName = 'tbradm', gameTypeName = 'Single'},
		--	{fromName = 'tbradm', gameTypeName = 'Single', teamPreviewEnabled = true}
	}

	local groupId, groupGui

	local battlingplayers = {}	

	local pvp = {
		updateBadgeNumber = function() end,
	}

	local function convertColor(color, hue)
		local _, s, v = Color3.toHSV(color)
		return Color3.fromHSV(hue or 0, s, v)
	end

	local BACKGROUND_COLOR_MAIN = Color3.fromHSV(0, .9, .5)--convertColor(Color3.new(0, .64, 1))--, 0, , -.2)
	--print(Color3.toHSV(BACKGROUND_COLOR_MAIN))

	local pvpLocations = {
		singles = {
			'Random',
			--'Super Bomb',
			'Colosseum',
			'Woods',
			'Ice Cave',
			'Arena',
			'Alola',
			'Docks',
			'Lab',
			'Rooftop',
			'Alley',
			'Castle',
			'Arcade',
			'Halloween',
			'Distortion',
		},
		doubles = {
			'Random',
			'Colosseum',
			'Volcano',
			'Swamp',
			'Gold Mine',
			'Ruins',
			'Cavern',
			'Ballroom',
			'Satellite',
			'Snowland',
		}
	}


	function pvp:init()
		network:bindEvent('BattleRequest', function(from, request)
			if request.error then
				if accepting and from == accepting.from then
					if accepting.loadTag then
						accepting.failed = true
						_p.DataManager:setLoading(accepting.loadTag, false)
					end
					accepting = nil
				end
				spawn(function() _p.Menu:enable() end)
				self:error(request.error, rqListGui.gui.ErrorText)
			elseif request.accepted then
				self:onRequestAccepted(from, request)
			elseif request.joinBattle then
				if accepting and accepting.loadTag then
					accepting.completed = true
					_p.DataManager:setLoading(accepting.loadTag, false)
				end
				accepting = nil
				self:beforeBattle()
				--			Utilities.print_r(request)
				-- this request is generated by the opponent in BattleClient's initializer
				_p.Battle:doPVPBattle {opponent = from, battleId = request.joinBattle, gameType = request.gameType,
					teamPreviewEnabled = request.teamPreviewEnabled, location = request.location, icons = request.icons,
					isRanked = request.isRanked}
				self:afterBattle()
				--		elseif request.teamPreview then
				--			local battle = _p.Battle.currentBattle
				--			if battle and battle.opponent == from then
				--				battle.opponentPartyPreview = request.teamPreview
				--			end
			elseif request.teamPreviewReady then
				local battle = _p.Battle.currentBattle
				if battle and (from == 'server' or battle.opponent == from) then
					battle.opponentReady = true
				end
			else
				self:receivedRequest(from, request)
			end
		end)
	end

	function pvp:beforeBattle()
		network:post('UpdateTitle', 'Battling')
		self.busy = true
		pcall(function() rqListGui.Parent = nil end)
		pcall(function() rqButton.Visible = false end)
	end

	function pvp:afterBattle()
		self.busy = false
		pcall(function() rqButton.Visible = true end)
	end

	function pvp:enable()
		globalError = create 'Frame' {
			BackgroundTransparency = 1.0,
			Size = UDim2.new(0.0, 0, 0.05, 0),
			Position = UDim2.new(0.5, 0, 0.9, 0),
			Parent = Utilities.backGui,
		}
		local rq = _p.RoundedFrame:new {
			Button = true,
			--		CornerRadius = 5,
			BackgroundColor3 = BACKGROUND_COLOR_MAIN,
			Size = UDim2.new(.2, 0, .075, 0),
			Position = UDim2.new(.775, 0, .9, 0),
			Parent = Utilities.backGui,
			MouseButton1Click = function()
				self:viewRequests()
			end,
		}
		write'Requests' {
			Frame = create 'Frame' {
				BackgroundTransparency = 1.0,
				Size = UDim2.new(0.0, 0, 0.7, 0),
				Position = UDim2.new(0.5, 0, 0.15, 0),
				ZIndex = 2, Parent = rq.gui,
			}, Scaled = true,
		}
		local badgeIcon = create 'ImageLabel' {
			BackgroundTransparency = 1.0,
			Image = 'rbxasset://textures/WhiteCircle.png',
			ImageColor3 = Color3.new(1, .2, .2),
			SizeConstraint = Enum.SizeConstraint.RelativeYY,
			Size = UDim2.new(-0.8, 0, 0.8, 0),
			Position = UDim2.new(0.1, 0, -0.25, 0),
			Visible = false,
			ZIndex = 3, Parent = rq.gui,
		}
		local badgeText = create 'Frame' {
			BackgroundTransparency = 1.0,
			Size = UDim2.new(0.0, 0, 0.8, 0),
			Position = UDim2.new(0.5, 0, 0.1, 0),
			ZIndex = 4, Parent = badgeIcon,
		}
		function self:updateBadgeNumber(n)
			badgeText:ClearAllChildren()
			if n == 0 then
				badgeIcon.Visible = false
				return
			end
			badgeIcon.Visible = true
			write(tostring(n)) {
				Frame = badgeText,
				Scaled = true,
			}
		end
		rqButton = rq
		self:updateBadgeNumber(#requests)

		pcall(function()
			local hostButton, joinButtons = unpack(_p.Network:get('2v2f', 'getButtons'))
			if hostButton then
				hostButton.MouseButton1Click:connect(function() self:host2v2() end)
			end
			if joinButtons then
				for _, button in pairs(joinButtons) do
					button.MouseButton1Click:connect(function() self:joinGroup(button) end)
				end
			end
		end)
		pcall(function()
			local specButtons = _p.Network:get('SpecF', 'getSpecButtons')
			if specButtons then
				for _, button in pairs(specButtons) do
					button.MouseButton1Click:connect(function() self:spectate(button) end)
				end
			end
		end)
		_p.Network:bindEvent('SpecE', function(e, arg1)
			if e == 'newButtons' then
				for _, button in pairs(arg1) do
					button.MouseButton1Click:connect(function() self:spectate(button) end)
				end
			end
		end)
	end

	local function tableCell()
		return create 'Frame' {
			BorderSizePixel = 0,
			ZIndex = 2,

			create 'Frame' {
				Name = 'PlayerName',
				BackgroundTransparency = 1.0,
				ClipsDescendants = true,
				Size = UDim2.new(0.24, 0, 0.6, 0),
				Position = UDim2.new(0.02, 0, 0.2, 0),
				ZIndex = 3,
			},
			create 'Frame' {
				Name = 'Level',
				BackgroundTransparency = 1.0,
				Size = UDim2.new(0.08, 0, 0.6, 0),
				Position = UDim2.new(0.275, 0, 0.2, 0),
				ZIndex = 3,
			},
			create 'Frame' {
				Name = 'BattleStyle',
				BackgroundTransparency = 1.0,
				Size = UDim2.new(0.08, 0, 0.6, 0),
				Position = UDim2.new(0.375, 0, 0.2, 0),
				ZIndex = 3,
			},
			create 'Frame' {
				Name = 'Rules',
				BackgroundTransparency = 1.0,
				Size = UDim2.new(0.08, 0, 0.6, 0),
				Position = UDim2.new(0.475, 0, 0.2, 0),
				ZIndex = 3,
			},
			create 'Frame' {
				Name = 'Ranked',
				BackgroundTransparency = 1.0,
				Size = UDim2.new(0.08, 0, 0.6, 0),
				Position = UDim2.new(0.575, 0, 0.2, 0),
				ZIndex = 3,
			},
			create 'Frame' {
				Name = 'TeamPreview',
				BackgroundTransparency = 1.0,
				Size = UDim2.new(0.08, 0, 0.6, 0),
				Position = UDim2.new(0.725, 0, 0.2, 0),
				ZIndex = 3,
			},
		}
	end

	do
		local gui
		function pvp:updateRequests()
			for i = #requests, 1, -1 do
				if requests[i].expired then
					table.remove(requests, i)
				end
			end
			if gui and gui.Parent then--and gui.Visible then
				local list = gui.gui.List
				local container = list.Container
				local ht = 0.04
				local contentRelativeSize = #requests*ht*container.AbsoluteSize.X/list.AbsoluteSize.Y
				list.CanvasSize = UDim2.new(list.Size.X.Scale, -1, contentRelativeSize * list.Size.Y.Scale, 0)
				container:ClearAllChildren()
				for i, request in pairs(requests) do
					local cell = tableCell()
					if i%2 == 1 then
						cell.BackgroundColor3 = convertColor(Color3.new(0, .48, .75))
					else
						cell.BackgroundTransparency = 1.0
					end
					cell.Size = UDim2.new(1.0, 0, ht, 0)
					cell.Position = UDim2.new(0.0, 0, ht*(i-1), 0)
					cell.Parent = container
					write(request.fromName) {
						Frame = cell.PlayerName,
						Scaled = true,
						TextXAlignment = Enum.TextXAlignment.Left,
					}
					write(request.forcedLevel and tostring(request.forcedLevel) or '--') {
						Frame = cell.Level,
						Scaled = true,
					}
					write(request.gameTypeName) {
						Frame = cell.BattleStyle,
						Scaled = true,
					}
					write 'Anything' {
						Frame = cell.Rules,
						Scaled = true,
					}
					write(request.teamPreviewEnabled and 'Yes' or 'No') {
						Frame = cell.TeamPreview,
						Scaled = true,
					}
					write(request.isRanked and 'Yes' or 'No') {
						Frame = cell.Ranked,
						Scaled = true,
					}
					local button = create 'TextButton' {
						Text = '',
						BackgroundColor3 = convertColor(Color3.new(0, .24, .5)),
						AutoButtonColor = false,
						BorderSizePixel = 0,
						Size = UDim2.new(.15, 0, 0.8, 0),
						Position = UDim2.new(0.83, 0, 0.1, 0),
						ZIndex = 3, Parent = cell,
						MouseButton1Click = function()
							if accepting or not _p.Menu.enabled then return end
							self:acceptRequest(request)
						end,
					}
					write 'Accept' {
						Frame = create 'Frame' {
							BackgroundTransparency = 1.0,
							Size = UDim2.new(0.0, 0, 0.8, 0),
							Position = UDim2.new(0.5, 0, 0.1, 0),
							ZIndex = 4, Parent = button,
						},
						Scaled = true,
					}
				end
			else
				local n = 0
				for _, r in pairs(requests) do
					if r.new then
						n = n + 1
					end
				end
				self:updateBadgeNumber(n)
			end
		end

		function pvp:viewRequests()
			if not gui then
				gui = _p.RoundedFrame:new {
					BackgroundColor3 = BACKGROUND_COLOR_MAIN,
					Size = UDim2.new(.7, 0, .7, 0),
					Parent = Utilities.backGui,

					create 'ScrollingFrame' {
						Name = 'List',
						--					BackgroundTransparency = 1.0,
						BackgroundColor3 = convertColor(BrickColor.new('Deep blue').Color),
						BorderSizePixel = 0,
						Size = UDim2.new(0.92, 0, 0.7, 0),
						Position = UDim2.new(0.04, 0, 0.2, 0),
						ZIndex = 2,

						create 'Frame' {
							Name = 'Container',
							BackgroundTransparency = 1.0,
							SizeConstraint = Enum.SizeConstraint.RelativeXX,
						}
					},
					create 'Frame' {
						Name = 'ErrorText',
						BackgroundTransparency = 1.0,
						Size = UDim2.new(0.0, 0, 0.05, 0),
						Position = UDim2.new(0.5, 0, 0.925, 0),
						ZIndex = 2,
					}
				}
				write 'Battle Requests' {
					Frame = create 'Frame' {
						BackgroundTransparency = 1.0,
						Size = UDim2.new(0.0, 0, 0.08, 0),
						Position = UDim2.new(0.5, 0, 0.01, 0),
						ZIndex = 2, Parent = gui.gui,
					}, Scaled = true,
				}
				local header = tableCell()
				header.BackgroundTransparency = 1.0
				local headerContainer = create 'Frame' {
					BorderSizePixel = 0,
					BackgroundColor3 = convertColor(BrickColor.new('Navy blue').Color),
					Size = UDim2.new(0.92, 0, 0.08, 0),
					Position = UDim2.new(0.04, 0, 0.12, 0),
					ZIndex = 2, Parent = gui.gui,
				}
				local function cr()
					gui.CornerRadius = Utilities.gui.AbsoluteSize.Y*.04
					local sbw = Utilities.gui.AbsoluteSize.Y*.035
					gui.gui.List.ScrollBarThickness = sbw
					gui.gui.List.Container.Size = UDim2.new(1.0, -sbw, 1.0, -sbw)
					header.Size = UDim2.new(1.0, -sbw, 1.0, 0)
				end
				Utilities.gui.Changed:connect(cr)
				cr()
				header.Parent = headerContainer
				write 'From' {
					Frame = header.PlayerName,
					Scaled = true,
					TextXAlignment = Enum.TextXAlignment.Left,
				}
				write 'All Lv.' {
					Frame = header.Level,
					Scaled = true,
				}
				write 'Style' {
					Frame = header.BattleStyle,
					Scaled = true,
				}
				write 'Rules' {
					Frame = header.Rules,
					Scaled = true,
				}
				write 'T.P.' {
					Frame = header.TeamPreview,
					Scaled = true,
				}
				write 'Ranked' {
					Frame = header.Ranked,
					Scaled = true,
				}
				rqListGui = gui
			elseif gui.Parent then
				gui.Parent = nil
				return
			end
			if battleRQgui then battleRQgui.Parent = nil end
			if hostGui then hostGui.Parent = nil end
			if specGui then pcall(specGui) end
			for _, r in pairs(requests) do
				r.new = false
			end
			self:updateBadgeNumber(0)
			gui.Parent = Utilities.backGui
			self:updateRequests()
			--		gui.Visible = true
			Utilities.Tween(.5, 'easeOutCubic', function(a)
				gui.Position = UDim2.new(.15, 0, .15-(1-a), 0)
			end)
		end

		function pvp:acceptRequest(request)
			if request.expired then
				self:updateRequests()
				self:error('This request has expired', gui.gui.ErrorText)
				return
			end
			if not request.from or not request.from.Parent then
				request.expired = true
				self:updateRequests()
				self:error('Opponent has left the game', gui.gui.ErrorText)
				return
			end
			_p.DataManager:preload('http://www.roblox.com/Thumbs/Avatar.ashx?x=420&y=420&Format=Png&userid='..math.max(1, request.from.UserId))

			spawn(function() _p.Menu:disable() end)
			accepting = request
			request.accepted = true
			local tag = {}
			_p.DataManager:setLoading(tag, true)
			network:post('BattleRequest', request.from, request)
			request.loadTag = tag
			wait(15)
			if not request.completed and not request.failed then
				accepting = nil
				_p.DataManager:setLoading(tag, false)
				self:error('Opponent not ready', gui.gui.ErrorText)
				_p.Menu:enable()
			end
		end
	end

	function pvp:onRequestAccepted(opponent, request)
		if self.busy or groupId or (_p.NPCChat.chatBox and _p.NPCChat.chatBox.Parent) or not _p.Menu.enabled then
			request.error = 'Player is busy'
			network:post('BattleRequest', opponent, request)
			return
		end

		-- Regular 1v1 battle handling
		_p.MasterControl.WalkEnabled = false
		_p.MasterControl:Stop()

		spawn(function() _p.Menu:disable() end)
		if not _p.NPCChat:say(opponent.Name .. ' accepted your battle request.', '[y/n]Are you ready to battle?') then
			request.error = 'The opponent canceled the battle'
			network:post('BattleRequest', opponent, request)
			_p.MasterControl.WalkEnabled = true
			--_p.MasterControl:Start()
			_p.Menu:enable()
			return
		end

		if not opponent or not opponent.Parent then
			self:error('The opponent left the game')
			_p.MasterControl.WalkEnabled = true
			--_p.MasterControl:Start()
			_p.Menu:enable()
			return
		end

		request.pseudoHost = true
		request.opponent = opponent
		self:beforeBattle()
		_p.Battle:doPVPBattle(request)
		self:afterBattle()
	end

	function pvp:receivedRequest(from, request)
		for i = #requests, 1, -1 do
			if requests[i].from == from then
				table.remove(requests, i)
			end
		end
		request.from = from
		request.fromName = from.Name
		request.new = true
		table.insert(requests, request)
		delay(60, function()
			request.expired = true
			self:updateRequests()
		end)
		self:updateRequests()
	end

	function pvp:error(txt, frame)
		if not frame and not battleRQgui then return end
		--	frame = frame or battleRQgui.gui.ErrorText
		frame = globalError
		frame:ClearAllChildren()
		local thisThread = {}
		errorThread = thisThread
		write(txt) {
			Frame = frame,
			Color = Color3.new(1, .2, .2),
			Scaled = true,
		}
		wait(3)
		if errorThread == thisThread then
			frame:ClearAllChildren()
		end
	end

	function pvp:sendRequest()
		if not settings.targetPlayer then self:error('No opponent selected') return end
		if not settings.targetPlayer.Parent then self:error('Selected opponent has left the colosseum') return end
		local wasRandom = false
		if settings.location == 'Random' then
			wasRandom = true
			local locations = pvpLocations[settings.gameType]
			settings.location = locations[math.random(2, #locations)]
		end
		network:post('BattleRequest', settings.targetPlayer, settings)
		if wasRandom then settings.location = 'Random' end
		return true
	end

	local function makeOptions(texts, values, key, defaultIndex, specificSettings, changedSignal)
		local settings = specificSettings or settings
		settings[key] = values[defaultIndex]
		settings[key..'Name'] = texts[defaultIndex]
		local container = create 'Frame' {
			BorderSizePixel = 0,
			BackgroundColor3 = convertColor(BrickColor.new('Deep blue').Color),
			ZIndex = 2
		}
		local buttons = {}
		for i, text in pairs(texts) do
			local button; button = create 'ImageButton' {
				AutoButtonColor = false,
				BorderSizePixel = defaultIndex==i and 4 or 0,
				BorderColor3 = convertColor(BrickColor.new('Black').Color),
				BackgroundColor3 = convertColor(BrickColor.new('Deep blue').Color),
				Size = UDim2.new(1/#texts, 0, 1.0, 0),
				Position = UDim2.new((i-1)/#texts, 0, 0.0, 0),
				ZIndex = defaultIndex==i and 4 or 3,
				Parent = container,
				MouseButton1Click = function()
					if settings[key] == values[i] then return end
					settings[key] = values[i]
					settings[key..'Name'] = texts[i]
					for _, b in pairs(buttons) do
						b.BorderSizePixel = 0
						b.ZIndex = 3
					end
					button.BorderSizePixel = 4
					button.ZIndex = 4
					if changedSignal then
						changedSignal:fire(key, values[i], texts[i])
					end
				end,
			}
			write(text) {
				Frame = create 'Frame' {
					BackgroundTransparency = 1.0,
					Size = UDim2.new(0.0, 0, 0.45, 0),
					Position = UDim2.new(0.5, 0, 0.275, 0),
					ZIndex = 4, Parent = button,
				}, Scaled = true,
			}
			table.insert(buttons, button)
		end
		return function(props)
			for prop, value in pairs(props) do
				container[prop] = value
			end
			return container
		end
	end

	function pvp:onClickedPlayer(player)
		if self.busy or groupId then return end

		if rqListGui then rqListGui.Parent = nil end
		if hostGui then hostGui.Parent = nil end
		if specGui then pcall(specGui) end

		settings.targetPlayer = player
		if not battleRQgui then
			battleRQgui = _p.RoundedFrame:new {
				Button = true,
				Selectable = false,
				BackgroundColor3 = BACKGROUND_COLOR_MAIN,
				Size = UDim2.new(.6, 0, .7, 0),
				Parent = Utilities.backGui,

				create 'Frame' {
					Name = 'VersusText',
					BackgroundTransparency = 1.0,
					Size = UDim2.new(0.0, 0, 0.075, 0),
					Position = UDim2.new(0.5, 0, 0.025, 0),
					ZIndex = 2,
				},
				create 'Frame' {
					Name = 'ErrorText',
					BackgroundTransparency = 1.0,
					Size = UDim2.new(0.0, 0, 0.05, 0),
					Position = UDim2.new(0.5, 0, 0.775, 0),
					ZIndex = 2,
				},
			}
			write 'Level' {
				Frame = create 'Frame' {
					BackgroundTransparency = 1.0,
					Size = UDim2.new(0.0, 0, 0.05, 0),
					Position = UDim2.new(0.085, 0, 0.175, 0),
					ZIndex = 2, Parent = battleRQgui.gui,
				}, Scaled = true,
			}
			makeOptions({'Unchanged', '5 All', '50 All', '100 All'}, {nil, 5, 50, 100}, 'forcedLevel', 3) {
				Size = UDim2.new(0.8, 0, 0.1, 0),
				Position = UDim2.new(0.15, 0, 0.15, 0),
				Parent = battleRQgui.gui,
			}
			write 'Style' {
				Frame = create 'Frame' {
					BackgroundTransparency = 1.0,
					Size = UDim2.new(0.0, 0, 0.05, 0),
					Position = UDim2.new(0.085, 0, 0.325, 0),
					ZIndex = 2, Parent = battleRQgui.gui,
				}, Scaled = true,
			}
			local gameTypeChanged = Utilities.Signal()
			makeOptions({'Single', 'Double'}, {'singles', 'doubles'}, 'gameType', 1, nil, gameTypeChanged) {
				Size = UDim2.new(0.4, 0, 0.1, 0),
				Position = UDim2.new(0.15, 0, 0.3, 0),
				Parent = battleRQgui.gui
			}
			write 'Rules' {
				Frame = create 'Frame' {
					BackgroundTransparency = 1.0,
					Size = UDim2.new(0.0, 0, 0.05, 0),
					Position = UDim2.new(0.085, 0, 0.475, 0),
					ZIndex = 2, Parent = battleRQgui.gui
				}, Scaled = true
			}
			makeOptions({'Anyth. Goes'}, {nil}, 'rules', 1) {
				Size = UDim2.new(0.2, 0, 0.1, 0),
				Position = UDim2.new(0.15, 0, 0.45, 0),
				Parent = battleRQgui.gui
			}

			-- BEGIN LOCATION
			write 'Location' {
				Frame = create 'Frame' {
					BackgroundTransparency = 1.0,
					Size = UDim2.new(0.0, 0, 0.05, 0),
					Position = UDim2.new(.66, 0, .475, 0),
					ZIndex = 2, Parent = battleRQgui.gui
				}, Scaled = true
			}
			local locationFrame = create 'Frame' {
				BackgroundTransparency = 1.0,
				Size = UDim2.new(0.0, 0, 0.45, 0),
				Position = UDim2.new(0.5, 0, 0.275, 0),
				ZIndex = 4
			}
			local locationButton = create 'ImageButton' {
				AutoButtonColor = false,
				BorderSizePixel = 0,
				BackgroundColor3 = convertColor(BrickColor.new('Deep blue').Color),
				Size = UDim2.new(0.2, 0, 0.1, 0),
				Position = UDim2.new(0.75, 0, 0.45, 0),
				ZIndex = 3, Parent = battleRQgui.gui,
				MouseButton1Click = function()
					local locationOptions = pvpLocations[settings.gameType]
					local mouseTrap = create 'ImageButton' {
						AutoButtonColor = false,
						BorderSizePixel = 0,
						BackgroundColor3 = Color3.new(0, 0, 0),
						BackgroundTransparency = .6,
						Size = UDim2.new(1.0, 0, 1.0, 36),
						Position = UDim2.new(0.0, 0, 0.0, -36),
						Parent = Utilities.frontGui
					}
					local sbw = Utilities.gui.AbsoluteSize.Y*.035
					local h = .25
					local list = create 'ScrollingFrame' {
						BorderColor3 = convertColor(BrickColor.new('Black').Color),
						BorderSizePixel = 2,
						BackgroundColor3 = Color3.new(.73, .13, .13),
						--					BackgroundTransparency = 1.0,
						ScrollBarThickness = sbw,
						Size = UDim2.new(0.12, 0, 0.5, 0),
						Position = UDim2.new(0.65, 0, 0.465, 0),
						ZIndex = 2, Parent = Utilities.frontGui
					}
					local container = create 'Frame' {
						BackgroundTransparency = 1.0,
						SizeConstraint = Enum.SizeConstraint.RelativeXX,
						Size = UDim2.new(1.0, -sbw, 1.0, -sbw),
						Parent = list
					}
					local contentRelativeSize = #locationOptions * h * container.AbsoluteSize.X / list.AbsoluteSize.Y
					--				print(contentRelativeSize)
					list.CanvasSize = UDim2.new(list.Size.X.Scale, -1, contentRelativeSize * list.Size.Y.Scale, 0)
					if contentRelativeSize < 1 then -- list is not yet full
						list.Size = UDim2.new(list.Size.X.Scale, 0, contentRelativeSize * list.Size.Y.Scale, 0)
					end

					for i, loc in pairs(locationOptions) do
						local isCurrent = settings.location == loc
						local button = create 'ImageButton' {
							--						AutoButtonColor = false,
							BorderSizePixel = 0,
							BackgroundColor3 = isCurrent and BACKGROUND_COLOR_MAIN or Color3.new(.73, .13, .13),
							Size = UDim2.new(1.0, 0, h, 0),
							Position = UDim2.new(0.0, 0, h*(i-1), 0),
							ZIndex = 3, Parent = container,
							MouseButton1Click = function()
								list:remove()
								mouseTrap:remove()
								if isCurrent then return end
								settings.location = loc
								locationFrame:ClearAllChildren()
								write(loc) {Frame = locationFrame, Scaled = true}
							end
						}
						write(loc) {
							Frame = create 'Frame' {
								BackgroundTransparency = 1.0,
								Size = UDim2.new(0.0, 0, 0.45, 0),
								Position = UDim2.new(0.5, 0, 0.275, 0),
								ZIndex = 4, Parent = button
							}, Scaled = true
						}
					end
					mouseTrap.MouseButton1Click:connect(function()
						list:remove()
						mouseTrap:remove()
					end)
				end
			}
			locationFrame.Parent = locationButton
			write 'Random' {Frame = locationFrame, Scaled = true}
			gameTypeChanged:connect(function(_, value, valueName)
				--			if not settings.location then return end
				settings.location = 'Random'
				locationFrame:ClearAllChildren()
				write 'Random' {Frame = locationFrame, Scaled = true}
			end)
			-- END LOCATION

			write 'Team Preview' {
				Frame = create 'Frame' {
					BackgroundTransparency = 1.0,
					Size = UDim2.new(0.0, 0, 0.05, 0),
					Position = UDim2.new(0.1625, 0, 0.625, 0),
					ZIndex = 2, Parent = battleRQgui.gui,
				}, Scaled = true
			}
			makeOptions({'Yes', 'No'}, {true, false}, 'teamPreviewEnabled', 1) {
				Size = UDim2.new(0.2, 0, 0.1, 0),
				Position = UDim2.new(0.305, 0, 0.6, 0),
				Parent = battleRQgui.gui
			}
			write 'Ranked' {
				Frame = create 'Frame' {
					BackgroundTransparency = 1.0,
					Size = UDim2.new(0.0, 0, 0.05, 0),
					Position = UDim2.new(0.1625, 0, 0.725, 0),
					ZIndex = 2, Parent = battleRQgui.gui,
				}, Scaled = true
			}
			makeOptions({'Yes', 'No'}, {true, false}, 'isRanked', 1) {
				Size = UDim2.new(0.2, 0, 0.1, 0),
				Position = UDim2.new(0.305, 0, 0.7, 0),
				Parent = battleRQgui.gui
			}
			write 'Spectate' {
				Frame = create 'Frame' {
					BackgroundTransparency = 1.0,
					Size = UDim2.new(0.0, 0, 0.05, 0),
					Position = UDim2.new(0.66, 0, 0.625, 0),
					ZIndex = 2, Parent = battleRQgui.gui,
				}, Scaled = true
			}
			makeOptions({'Allow', 'Block'}, {true, false}, 'allowSpectate', 1) {
				Size = UDim2.new(0.2, 0, 0.1, 0),
				Position = UDim2.new(0.75, 0, 0.6, 0),
				Parent = battleRQgui.gui
			}

			local cancel = _p.RoundedFrame:new {
				Button = true,
				BackgroundColor3 = convertColor(Color3.new(0, .48, .75)),
				Size = UDim2.new(.3, 0, .125, 0),
				Position = UDim2.new(0.125, 0, 0.85, 0),
				ZIndex = 2, Parent = battleRQgui.gui,
				MouseButton1Click = function()
					battleRQgui.Parent = nil
				end
			}
			local send = _p.RoundedFrame:new {
				Button = true,
				BackgroundColor3 = convertColor(Color3.new(0, .48, .75)),
				Size = UDim2.new(.3, 0, .125, 0),
				Position = UDim2.new(0.575, 0, 0.85, 0),
				ZIndex = 2, Parent = battleRQgui.gui,
				MouseButton1Click = function()
					if self:sendRequest() then
						battleRQgui.Parent = nil
					end
				end
			}
			write 'Cancel' {
				Frame = create 'Frame' {
					BackgroundTransparency = 1.0,
					Size = UDim2.new(0.0, 0, 0.7, 0),
					Position = UDim2.new(0.5, 0, 0.15, 0),
					ZIndex = 3, Parent = cancel.gui,
				}, Scaled = true,
			}
			write 'Send' {
				Frame = create 'Frame' {
					BackgroundTransparency = 1.0,
					Size = UDim2.new(0.0, 0, 0.7, 0),
					Position = UDim2.new(0.5, 0, 0.15, 0),
					ZIndex = 3, Parent = send.gui,
				}, Scaled = true,
			}
			local function cr()
				battleRQgui.CornerRadius = Utilities.gui.AbsoluteSize.Y*.04
				cancel.CornerRadius = Utilities.gui.AbsoluteSize.Y*.03
				send.CornerRadius = Utilities.gui.AbsoluteSize.Y*.03
			end
			Utilities.gui.Changed:connect(cr)
			cr()
			battleRQgui.Parent = nil
		end
		local gui = battleRQgui.gui
		gui.VersusText:ClearAllChildren()
		write('Battle with '..(player and player.Name or 'NULL')) {
			Frame = gui.VersusText,
			Scaled = true,
		}
		if not battleRQgui.Parent then
			battleRQgui.Parent = Utilities.backGui
			Utilities.Tween(.5, 'easeOutCubic', function(a)
				battleRQgui.Position = UDim2.new(.2, 0, .15-(1-a), 0)
			end)
		end
	end

	function pvp:joinGroup(button)
		if self.busy then return end
		if rqListGui then rqListGui.Parent = nil end
		if battleRQgui then battleRQgui.Parent = nil end
		if hostGui then hostGui.Parent = nil end
		if specGui then pcall(specGui) end

		local id = _p.Network:get('2v2f', 'joinGroup', button)
		if not id then return end
		groupId = id
	end

	_p.Network:bindEvent('2v2e', function(fn, arg1, ...)
		if fn == 'newButton' then
			arg1.MouseButton1Click:connect(function() pvp:joinGroup(arg1) end)
		elseif fn == 'updateMembers' then
			local playerList = arg1
			if not playerList then -- kicked or disbanded; todo: add message
				if groupGui then
					groupGui.Main.Parent = nil
					groupGui.MemberCount = 0
					for _, container in pairs(groupGui.MemberContainers) do
						container.CurrentName = nil
						container.NameContainer:ClearAllChildren()
					end
				end
				groupId = nil
				pcall(function() rqButton.Visible = true end)
				_p.MasterControl.WalkEnabled = true
				--_p.MasterControl:Start()
				_p.Menu:enable()
				return
			end
			local ready = select(1, ...) or {}
			if not groupGui then
				local BACKGROUND_COLOR = convertColor(Color3.fromRGB(47, 69, 99))
				local BORDER_COLOR = convertColor(Color3.fromRGB(25, 35, 50))
				groupGui = {
					BackgroundColorNormal = BACKGROUND_COLOR,
					BorderColorNormal = BORDER_COLOR,
					BackgroundColorReady = convertColor(BACKGROUND_COLOR, 1/3),--Color3.fromRGB(73, 165, 73),--
					BorderColorReady = convertColor(BORDER_COLOR, 1/3),
					MemberCount = 0
				}
				local main = create 'Frame' {
					BorderColor3 = BORDER_COLOR,
					BorderSizePixel = 2,
					BackgroundColor3 = BACKGROUND_COLOR,
					Size = UDim2.new(.3, 0, .15, 0),
					Position = UDim2.new(.05, 0, .8, 0)
				}
				write 'vs' {
					Frame = create 'Frame' {
						BackgroundTransparency = 1.0,
						Size = UDim2.new(.0, 0, .2, 0),
						Position = UDim2.new(.5, 0, .4, 0),
						ZIndex = 6, Parent = main
					}, Scaled = true
				}
				groupGui.Main = main
				local header = create 'Frame' {
					BorderColor3 = BORDER_COLOR,
					BorderSizePixel = 2,
					BackgroundColor3 = BACKGROUND_COLOR,
					Size = UDim2.new(1.0, 0, .4, 0),
					Position = UDim2.new(.0, 0, -.4, -6),
					Parent = main
				}
				write 'Battle Group' {
					Frame = create 'Frame' {
						BackgroundTransparency = 1.0,
						Size = UDim2.new(.6, 0, .6, 0),
						Position = UDim2.new(.0, 0, .2, 0),
						ZIndex = 2, Parent = header
					}, Scaled = true
				}
				-- start button
				local sButton = create 'ImageButton' {
					AutoButtonColor = false,
					BorderColor3 = BORDER_COLOR,
					BackgroundColor3 = BACKGROUND_COLOR,
					Size = UDim2.new(.175, 0, .7, 0),
					Position = UDim2.new(.6, 0, .15, 0),
					ZIndex = 2, Parent = header,
					MouseButton1Click = function()
						if groupGui.ReadyText.Visible and groupGui.StartButton.BackgroundColor3 == groupGui.BackgroundColorReady then
							_p.Network:post('2v2e', 'setReady', groupId, false)
						else
							_p.Network:post('2v2e', 'setReady', groupId, true)
						end
					end
				}
				groupGui.StartButton = sButton
				groupGui.StartDisabler = create 'Frame' {
					BorderSizePixel = 0,
					BackgroundTransparency = .5,
					BackgroundColor3 = BACKGROUND_COLOR,
					Size = UDim2.new(1.0, -2, 1.0, -2),
					Position = UDim2.new(.0, 1, .0, 1),
					ZIndex = 4, Parent = sButton
				}
				groupGui.StartText = write 'Start' {
					Frame = create 'Frame' {
						BackgroundTransparency = 1.0,
						Size = UDim2.new(.0, 0, .6, 0),
						Position = UDim2.new(.5, 0, .2, 0),
						ZIndex = 3, Parent = sButton
					}, Scaled = true
				}.Frame
				groupGui.ReadyText = write 'Ready' {
					Frame = create 'Frame' {
						BackgroundTransparency = 1.0,
						Size = UDim2.new(.0, 0, 0.6, 0),
						Position = UDim2.new(.5, 0, .2, 0),
						ZIndex = 3, Parent = sButton
					}, Scaled = true
				}.Frame
				-- leave button
				local lButton = create 'ImageButton' {
					AutoButtonColor = false,
					BorderColor3 = BORDER_COLOR,
					BackgroundColor3 = BACKGROUND_COLOR,
					Size = UDim2.new(.175, 0, .7, 0),
					Position = UDim2.new(.8, 0, .15, 0),
					ZIndex = 2, Parent = header,
					MouseButton1Click = function()
						if _p.Network:get('2v2f', 'leaveGroup', groupId) then
							groupGui.Main.Parent = nil
							groupGui.MemberCount = 0
							for _, container in pairs(groupGui.MemberContainers) do
								container.CurrentName = nil
								container.NameContainer:ClearAllChildren()
							end
							groupId = nil
							pcall(function() rqButton.Visible = true end)
							_p.MasterControl.WalkEnabled = true
							--_p.MasterControl:Start()
							_p.Menu:enable()
						end
					end
				}
				write 'Leave' {
					Frame = create 'Frame' {
						BackgroundTransparency = 1.0,
						Size = UDim2.new(.0, 0, .6, 0),
						Position = UDim2.new(.5, 0, .2, 0),
						ZIndex = 2, Parent = lButton
					}, Scaled = true
				}
				local mContainers = {}
				local cAnchorPoints, cPositions = {}, {}
				for i = 1, 4 do
					local container = {
						--					Location = i
					}
					mContainers[i] = container
					local top = i<3
					local left = i%2==1
					local anchorPoint = Vector2.new(left and 0 or 1, top and 0 or 1)
					cAnchorPoints[i] = anchorPoint
					local position = UDim2.new(left and .0 or 1.0, left and 2 or -2, top and .0 or 1.0, top and 2 or -2)
					cPositions[i] = position
					local cMain = create 'Frame' {
						ClipsDescendants = true,
						BorderColor3 = BORDER_COLOR,
						BackgroundColor3 = BACKGROUND_COLOR,
						Size = UDim2.new(.45, -4, .5, -4),
						AnchorPoint = anchorPoint,
						Position = position,
						ZIndex = 2, Parent = main
					}
					container.Main = cMain
					container.NameContainer = create 'Frame' {
						BackgroundTransparency = 1.0,
						Size = UDim2.new(.0, 0, .4, 0),
						Position = UDim2.new(.05, 0, .3, 0),
						ZIndex = 3, Parent = cMain
					}
					-- team button
					local tButton = create 'ImageButton' {
						AutoButtonColor = false,
						BorderColor3 = BORDER_COLOR,
						BackgroundColor3 = BACKGROUND_COLOR,
						Size = UDim2.new(.2, 0, .5, -4),
						AnchorPoint = Vector2.new(1, 0),
						Position = UDim2.new(1.0, -2, .0, 2),
						ZIndex = 3, Parent = cMain,
						MouseButton1Click = function()
							if not container.CurrentName then return end
							_p.Network:post('2v2e', 'teamWith', container.CurrentName)
						end
					}
					container.TeamButton = tButton
					write 'Team' {
						Frame = create 'Frame' {
							BackgroundTransparency = 1.0,
							Size = UDim2.new(0.0, 0, 0.6, 0),
							Position = UDim2.new(0.5, 0, 0.2, 0),
							ZIndex = 4, Parent = tButton
						}, Scaled = true
					}
					-- kick button
					local kButton = create 'ImageButton' {
						AutoButtonColor = false,
						BorderColor3 = BORDER_COLOR,
						BackgroundColor3 = BACKGROUND_COLOR,
						Size = UDim2.new(.2, 0, .5, -4),
						AnchorPoint = Vector2.new(1, 1),
						Position = UDim2.new(1.0, -2, 1.0, -2),
						ZIndex = 3, Parent = cMain,
						MouseButton1Click = function()
							if not container.CurrentName then return end
							_p.Network:post('2v2e', 'kick', container.CurrentName)
						end
					}
					container.KickButton = kButton
					write 'Kick' {
						Frame = create 'Frame' {
							BackgroundTransparency = 1.0,
							Size = UDim2.new(0.0, 0, 0.6, 0),
							Position = UDim2.new(0.5, 0, 0.2, 0),
							ZIndex = 4, Parent = kButton
						}, Scaled = true
					}
				end
				groupGui.MemberContainers = mContainers
				groupGui.MemberAnchorPoints = cAnchorPoints
				groupGui.MemberPositions = cPositions
			end

			local amHost = (playerList[1] == _p.player)
			groupGui.StartText.Visible = amHost
			groupGui.ReadyText.Visible = not amHost


			-- BEGIN REARRANGEMENT
			local oldOrder = groupGui.MemberContainers
			local newOrder = Utilities.shallowcopy(oldOrder)
			-- check for removing players; clear cells
			local newCount = #playerList
			local isMember = {}
			for _, player in pairs(playerList) do
				isMember[player.Name] = true
			end
			local moves = {} -- [from] = to
			local --[[isMovingFrom, isMovingTo,]] doesNeedCell, isClear = {}, {}--, {}, {}
			for i = groupGui.MemberCount+1, 4 do
				isClear[i] = true
			end
			for i, container in pairs(oldOrder) do
				if not isMember[container.CurrentName] then
					isClear[i] = true
					container.CurrentName = nil
					container.NameContainer:ClearAllChildren()
				end
			end
			-- determined where non-new players need to move
			for newIndex, player in pairs(playerList) do
				local oldIndex
				for index, container in pairs(oldOrder) do
					if container.CurrentName == player.Name then
						oldIndex = index
						break
					end
				end
				if oldIndex then
					moves[oldIndex] = newIndex
					newOrder[newIndex] = oldOrder[oldIndex]
					--				isMovingFrom[oldIndex] = true
					--				isMovingTo[newIndex] = true
				else
					doesNeedCell[#doesNeedCell+1] = newIndex--doesNeedCell[i] = true
				end
			end
			-- add new players and determine where to move
			while true do
				local newIndex = table.remove(doesNeedCell, 1)
				if not newIndex then break end
				local oldIndex
				for i = 1, 4 do
					if isClear[i] then
						isClear[i] = false
						oldIndex = i
						break
					end
				end
				moves[oldIndex] = newIndex
				newOrder[newIndex] = oldOrder[oldIndex]
				--			isMovingFrom[oldIndex] = true
				--			isMovingTo[newIndex] = true
				-- fill info
				local playerName = playerList[newIndex].Name
				local container = oldOrder[oldIndex]
				container.CurrentName = playerName
				write(playerName) {
					Frame = container.NameContainer,
					Scaled = true,
					TextXAlignment = Enum.TextXAlignment.Left,
					Color = Utilities.GetNameColor(playerName)
				}
			end
			-- move empty cells as necessary
			local moveTo = newCount+1
			for i = 1, newCount do
				if isClear[i] then
					oldOrder[i].Main.Visible = false
					--				moves[i] = moveTo
					newOrder[moveTo] = oldOrder[i]
					--				isMovingFrom[i] = true
					--				isMovingTo[moveTo] = true
					moveTo = moveTo + 1
				end
			end
			-- hide empty, non-moving cells
			for i = newCount+1, 4 do
				newOrder[i].Main.Visible = false
			end
			-- set values
			groupGui.MemberContainers = newOrder
			groupGui.MemberCount = newCount
			-- animate moves
			Utilities.fastSpawn(function()
				local thisThread = {}
				groupGui.UpdateThread = thisThread

				local md = {}
				for from, to in pairs(moves) do
					local cMain = oldOrder[from].Main
					if cMain.Visible then
						table.insert(md, {cMain, Utilities.lerpVector2(cMain.AnchorPoint, groupGui.MemberAnchorPoints[to]),
							Utilities.lerpUDim2(cMain.Position, groupGui.MemberPositions[to])})
					else
						cMain.AnchorPoint = groupGui.MemberAnchorPoints[to]
						cMain.Position = groupGui.MemberPositions[to]
						cMain.Visible = true
					end
				end
				if #md > 0 then
					Utilities.Tween(.5, 'easeOutCubic', function(a)
						if groupGui.UpdateThread ~= thisThread then return false end
						for _, m in pairs(md) do
							local c, ap, p = unpack(m)
							c.AnchorPoint = ap(a)
							c.Position = p(a)
						end
					end)
				end
			end)
			-- END REARRANGEMENT

			newOrder[1].KickButton.Visible = false
			newOrder[2].KickButton.Visible = amHost
			newOrder[3].KickButton.Visible = amHost
			newOrder[4].KickButton.Visible = amHost

			newOrder[1].TeamButton.Visible = false
			newOrder[2].TeamButton.Visible = amHost and newCount>2
			newOrder[3].TeamButton.Visible = false
			newOrder[4].TeamButton.Visible = amHost

			if amHost then
				groupGui.StartDisabler.Visible = true
				if newCount == 4 then
					local allReady = true
					for i = 2, 4 do
						local name = newOrder[i].CurrentName
						if not name or not ready[name] then
							allReady = false
							break
						end
					end
					if allReady then
						groupGui.StartDisabler.Visible = false
					end
				end
			else
				groupGui.StartDisabler.Visible = false
			end

			for i, container in pairs(newOrder) do
				local name = container.CurrentName
				if name then
					local isReady = ready[name]
					container.Main.BackgroundColor3 = isReady and groupGui.BackgroundColorReady or groupGui.BackgroundColorNormal
					container.Main.BorderColor3 = isReady and groupGui.BorderColorReady or groupGui.BorderColorNormal
				end
			end
			local amReady = ready[_p.player.Name] and true or false
			groupGui.StartButton.BackgroundColor3 = amReady and groupGui.BackgroundColorReady or groupGui.BackgroundColorNormal
			groupGui.StartButton.BorderColor3 = amReady and groupGui.BorderColorReady or groupGui.BorderColorNormal
			_p.MasterControl.WalkEnabled = not amReady
			if amReady then _p.MasterControl:Stop() end
			spawn(function() _p.Menu[amReady and 'disable' or 'enable'](_p.Menu) end)

			pcall(function() rqListGui.Parent = nil end)
			pcall(function() rqButton.Visible = false end)
			if not _p.Battle.currentBattle then
				groupGui.Main.Parent = Utilities.backGui
			end
		elseif fn == 'updateReady' then
			if not groupGui then return end
			local ready = arg1

			local mContainers = groupGui.MemberContainers
			if mContainers[1].CurrentName == _p.player.Name then
				groupGui.StartDisabler.Visible = true
				if groupGui.MemberCount == 4 then
					local allReady = true
					for i = 2, 4 do
						local name = mContainers[i].CurrentName
						if not name or not ready[name] then
							allReady = false
							break
						end
					end
					if allReady then
						groupGui.StartDisabler.Visible = false
					end
				end
			else
				groupGui.StartDisabler.Visible = false
			end

			for i, container in pairs(groupGui.MemberContainers) do
				local name = container.CurrentName
				if name then
					local isReady = ready[name]
					container.Main.BackgroundColor3 = isReady and groupGui.BackgroundColorReady or groupGui.BackgroundColorNormal
					container.Main.BorderColor3 = isReady and groupGui.BorderColorReady or groupGui.BorderColorNormal
				end
			end
			local amReady = ready[_p.player.Name] and true or false
			groupGui.StartButton.BackgroundColor3 = amReady and groupGui.BackgroundColorReady or groupGui.BackgroundColorNormal
			groupGui.StartButton.BorderColor3 = amReady and groupGui.BorderColorReady or groupGui.BorderColorNormal
			_p.MasterControl.WalkEnabled = not amReady
			if amReady then _p.MasterControl:Stop() end
			spawn(function() _p.Menu[amReady and 'disable' or 'enable'](_p.Menu) end)
		elseif fn == 'joinBattle' then
			_p.MasterControl.WalkEnabled = false
			_p.MasterControl:Stop()
			spawn(function() _p.Menu:disable() end)

			-- temporary setup
			--		_p.Battle._TeamPreview:prepare(arg1)
			--		spawn(function()_p.Battle._TeamPreview:getOrder(arg1)end)
			--		_p.Battle._TeamPreview:startTimer(true)

			groupGui.Main.Parent = nil
			_p.Battle:do2v2Battle(arg1)
			if groupId then
				groupGui.Main.Parent = Utilities.backGui
			end
		end
	end)

	function pvp:host2v2()
		if groupId or (groupGui and groupGui.Parent) then return end
		if rqListGui then rqListGui.Parent = nil end
		if battleRQgui then battleRQgui.Parent = nil end
		if specGui then pcall(specGui) end
		if not hostGui then
			hostGui = _p.RoundedFrame:new {
				Button = true,
				Selectable = false,
				BackgroundColor3 = BACKGROUND_COLOR_MAIN,
				Size = UDim2.new(.6, 0, .7, 0),
				Parent = Utilities.backGui,

				create 'Frame' {
					Name = 'ErrorText',
					BackgroundTransparency = 1.0,
					Size = UDim2.new(0.0, 0, 0.05, 0),
					Position = UDim2.new(0.5, 0, 0.775, 0),
					ZIndex = 2
				}
			}
			write 'Host 2v2 Battle' {
				Frame = create 'Frame' {
					BackgroundTransparency = 1.0,
					Size = UDim2.new(0.0, 0, 0.075, 0),
					Position = UDim2.new(0.5, 0, 0.025, 0),
					ZIndex = 2, Parent = hostGui.gui
				}, Scaled = true
			}
			write 'Level' {
				Frame = create 'Frame' {
					BackgroundTransparency = 1.0,
					Size = UDim2.new(0.0, 0, 0.05, 0),
					Position = UDim2.new(0.085, 0, 0.175, 0),
					ZIndex = 2, Parent = hostGui.gui
				}, Scaled = true
			}
			makeOptions({'Unchanged', '5 All', '50 All', '100 All'}, {nil, 5, 50, 100}, 'forcedLevel', 3, settings2v2) {
				Size = UDim2.new(0.8, 0, 0.1, 0),
				Position = UDim2.new(0.15, 0, 0.15, 0),
				Parent = hostGui.gui
			}
			write 'Invite-only' {
				Frame = create 'Frame' {
					BackgroundTransparency = 1.0,
					Size = UDim2.new(0.0, 0, 0.05, 0),
					Position = UDim2.new(0.123, 0, 0.325, 0),
					ZIndex = 2, Parent = hostGui.gui
				}, Scaled = true, Transparency = .5 -- disabled
			}
			makeOptions({'Yes', 'No'}, {true, false}, 'inviteOnly', 2, settings2v2) {
				Size = UDim2.new(0.2, 0, 0.1, 0),
				Position = UDim2.new(0.228, 0, 0.3, 0),
				Parent = hostGui.gui
			}
			write 'Rules' {
				Frame = create 'Frame' {
					BackgroundTransparency = 1.0,
					Size = UDim2.new(0.0, 0, 0.05, 0),
					Position = UDim2.new(0.085, 0, 0.475, 0),
					ZIndex = 2, Parent = hostGui.gui
				}, Scaled = true
			}
			makeOptions({'Anyth. Goes'}, {nil}, 'rules', 1, settings2v2) {
				Size = UDim2.new(0.2, 0, 0.1, 0),
				Position = UDim2.new(0.15, 0, 0.45, 0),
				Parent = hostGui.gui
			}
			-- BEGIN LOCATION
			write 'Location' {
				Frame = create 'Frame' {
					BackgroundTransparency = 1.0,
					Size = UDim2.new(0.0, 0, 0.05, 0),
					Position = UDim2.new(.66, 0, .475, 0),
					ZIndex = 2, Parent = hostGui.gui
				}, Scaled = true
			}
			local locationFrame = create 'Frame' {
				BackgroundTransparency = 1.0,
				Size = UDim2.new(0.0, 0, 0.45, 0),
				Position = UDim2.new(0.5, 0, 0.275, 0),
				ZIndex = 4
			}
			local locationButton = create 'ImageButton' {
				AutoButtonColor = false,
				BorderSizePixel = 0,
				BackgroundColor3 = convertColor(BrickColor.new('Deep blue').Color),
				Size = UDim2.new(0.2, 0, 0.1, 0),
				Position = UDim2.new(0.75, 0, 0.45, 0),
				ZIndex = 3, Parent = hostGui.gui,
				MouseButton1Click = function()
					local locationOptions = pvpLocations.doubles
					local mouseTrap = create 'ImageButton' {
						AutoButtonColor = false,
						BorderSizePixel = 0,
						BackgroundColor3 = Color3.new(0, 0, 0),
						BackgroundTransparency = .6,
						Size = UDim2.new(1.0, 0, 1.0, 36),
						Position = UDim2.new(0.0, 0, 0.0, -36),
						Parent = Utilities.frontGui
					}
					local sbw = Utilities.gui.AbsoluteSize.Y*.035
					local h = .25
					local list = create 'ScrollingFrame' {
						BorderColor3 = convertColor(BrickColor.new('Black').Color),
						BorderSizePixel = 2,
						BackgroundColor3 = Color3.new(.73, .13, .13),
						ScrollBarThickness = sbw,
						Size = UDim2.new(0.12, 0, 0.5, 0),
						Position = UDim2.new(0.65, 0, 0.465, 0),
						ZIndex = 2, Parent = Utilities.frontGui
					}
					local container = create 'Frame' {
						BackgroundTransparency = 1.0,
						SizeConstraint = Enum.SizeConstraint.RelativeXX,
						Size = UDim2.new(1.0, -sbw, 1.0, -sbw),
						Parent = list
					}
					local contentRelativeSize = #locationOptions * h * container.AbsoluteSize.X / list.AbsoluteSize.Y
					list.CanvasSize = UDim2.new(list.Size.X.Scale, -1, contentRelativeSize * list.Size.Y.Scale, 0)
					if contentRelativeSize < 1 then -- list is not yet full
						list.Size = UDim2.new(list.Size.X.Scale, 0, contentRelativeSize * list.Size.Y.Scale, 0)
					end

					for i, loc in pairs(locationOptions) do
						local isCurrent = settings2v2.location == loc
						local button = create 'ImageButton' {
							BorderSizePixel = 0,
							BackgroundColor3 = isCurrent and BACKGROUND_COLOR_MAIN or Color3.new(.73, .13, .13),
							Size = UDim2.new(1.0, 0, h, 0),
							Position = UDim2.new(0.0, 0, h*(i-1), 0),
							ZIndex = 3, Parent = container,
							MouseButton1Click = function()
								list:remove()
								mouseTrap:remove()
								if isCurrent then return end
								settings2v2.location = loc
								locationFrame:ClearAllChildren()
								write(loc) {Frame = locationFrame, Scaled = true}
							end
						}
						write(loc) {
							Frame = create 'Frame' {
								BackgroundTransparency = 1.0,
								Size = UDim2.new(0.0, 0, 0.45, 0),
								Position = UDim2.new(0.5, 0, 0.275, 0),
								ZIndex = 4, Parent = button
							}, Scaled = true
						}
					end
					mouseTrap.MouseButton1Click:connect(function()
						list:remove()
						mouseTrap:remove()
					end)
				end
			}
			locationFrame.Parent = locationButton
			write 'Random' {Frame = locationFrame, Scaled = true}
			-- END LOCATION

			write 'Team Preview' {
				Frame = create 'Frame' {
					BackgroundTransparency = 1.0,
					Size = UDim2.new(0.0, 0, 0.05, 0),
					Position = UDim2.new(0.158, 0, 0.625, 0),
					ZIndex = 2, Parent = hostGui.gui
				}, Scaled = true
			}
			makeOptions({'Yes', 'No'}, {true, false}, 'teamPreviewEnabled', 1, settings2v2) {
				Size = UDim2.new(0.2, 0, 0.1, 0),
				Position = UDim2.new(0.3, 0, 0.6, 0),
				Parent = hostGui.gui
			}
			write 'Spectate' {
				Frame = create 'Frame' {
					BackgroundTransparency = 1.0,
					Size = UDim2.new(0.0, 0, 0.05, 0),
					Position = UDim2.new(0.66, 0, 0.625, 0),
					ZIndex = 2, Parent = hostGui.gui
				}, Scaled = true, Transparency = .5 -- disabled
			}
			makeOptions({'Allow', 'Block'}, {true, false}, 'allowSpectate', 1) {
				Size = UDim2.new(0.2, 0, 0.1, 0),
				Position = UDim2.new(0.75, 0, 0.6, 0),
				Parent = hostGui.gui
			}

			local cancel = _p.RoundedFrame:new {
				Button = true,
				BackgroundColor3 = convertColor(Color3.new(0, .48, .75)),
				Size = UDim2.new(.3, 0, .125, 0),
				Position = UDim2.new(0.125, 0, 0.85, 0),
				ZIndex = 2, Parent = hostGui.gui,
				MouseButton1Click = function()
					hostGui.Parent = nil
				end
			}
			local host = _p.RoundedFrame:new {
				Button = true,
				BackgroundColor3 = convertColor(Color3.new(0, .48, .75)),
				Size = UDim2.new(.3, 0, .125, 0),
				Position = UDim2.new(0.575, 0, 0.85, 0),
				ZIndex = 2, Parent = hostGui.gui,
				MouseButton1Click = function()
					local id = _p.Network:get('2v2f', 'hostGroup', settings2v2)
					if id then
						groupId = id
						hostGui.Parent = nil
					end
				end
			}
			write 'Cancel' {
				Frame = create 'Frame' {
					BackgroundTransparency = 1.0,
					Size = UDim2.new(0.0, 0, 0.7, 0),
					Position = UDim2.new(0.5, 0, 0.15, 0),
					ZIndex = 3, Parent = cancel.gui
				}, Scaled = true
			}
			write 'Host' {
				Frame = create 'Frame' {
					BackgroundTransparency = 1.0,
					Size = UDim2.new(0.0, 0, 0.7, 0),
					Position = UDim2.new(0.5, 0, 0.15, 0),
					ZIndex = 3, Parent = host.gui
				}, Scaled = true
			}
			local function cr()
				hostGui.CornerRadius = Utilities.gui.AbsoluteSize.Y*.04
				cancel.CornerRadius = Utilities.gui.AbsoluteSize.Y*.03
				host.CornerRadius = Utilities.gui.AbsoluteSize.Y*.03
			end
			Utilities.gui.Changed:connect(cr)
			cr()
		elseif hostGui.Parent then
			return
		end
		hostGui.Parent = Utilities.backGui
		Utilities.Tween(.5, 'easeOutCubic', function(a)
			hostGui.Position = UDim2.new(.2, 0, .15-(1-a), 0)
		end)
	end

	function pvp:spectate(button)
		if rqListGui then rqListGui.Parent = nil end
		if battleRQgui then battleRQgui.Parent = nil end
		if hostGui then hostGui.Parent = nil end

		local data = _p.Network:get('SpecF', 'onClick', button)
		--	local data = {name1 = 'WoahhBob', name2 = 'lando64000'}
		if specGui then pcall(specGui) end
		if data then
			-- 2v2specdo
			local cornerSize = Utilities.gui.AbsoluteSize.Y*.03
			local smCornerSize = Utilities.gui.AbsoluteSize.Y*.02
			local buttonColor = convertColor(Color3.new(0, .48, .75))
			local gui = _p.RoundedFrame:new {
				CornerRadius = cornerSize,
				BackgroundColor3 = BACKGROUND_COLOR_MAIN,
				Size = UDim2.new(.45, 0, .4, 0),
				Position = UDim2.new(.275, 0, .3, 0),
				Parent = Utilities.frontGui
			}
			local spec1 = _p.RoundedFrame:new {
				Button = true,
				CornerRadius = smCornerSize,
				BackgroundColor3 = buttonColor,
				Size = UDim2.new(.9, 0, .2, 0),
				Position = UDim2.new(.05, 0, .1, 0),
				ZIndex = 2, Parent = gui.gui,
				MouseButton1Click = function()
					if specGui then pcall(specGui) end
					if self.busy or groupId then return end
					self.busy = true
					pcall(function() rqListGui.Parent = nil end)
					pcall(function() rqButton.Visible = false end)
					_p.Battle:spectate(data, 1)
					self.busy = false
					pcall(function() rqButton.Visible = true end)
				end
			}
			Utilities.Write('Spectate as '..data.name1) {
				Frame = Utilities.Create 'Frame' {
					BackgroundTransparency = 1.0,
					Size = UDim2.new(0.0, 0, 0.5, 0),
					Position = UDim2.new(0.5, 0, 0.25, 0),
					ZIndex = 3, Parent = spec1.gui
				}, Scaled = true
			}
			local spec2 = _p.RoundedFrame:new {
				Button = true,
				CornerRadius = smCornerSize,
				BackgroundColor3 = buttonColor,
				Size = UDim2.new(.9, 0, .2, 0),
				Position = UDim2.new(.05, 0, .4, 0),
				ZIndex = 2, Parent = gui.gui,
				MouseButton1Click = function()
					if specGui then pcall(specGui) end
					if self.busy or groupId then return end
					self.busy = true
					pcall(function() rqListGui.Parent = nil end)
					pcall(function() rqButton.Visible = false end)
					_p.Battle:spectate(data, 2)
					self.busy = false
					pcall(function() rqButton.Visible = true end)
				end
			}
			Utilities.Write('Spectate as '..data.name2) {
				Frame = Utilities.Create 'Frame' {
					BackgroundTransparency = 1.0,
					Size = UDim2.new(0.0, 0, 0.5, 0),
					Position = UDim2.new(0.5, 0, 0.25, 0),
					ZIndex = 3, Parent = spec2.gui
				}, Scaled = true
			}
			local cancel; cancel = _p.RoundedFrame:new {
				Button = true,
				CornerRadius = smCornerSize,
				BackgroundColor3 = buttonColor,
				Size = UDim2.new(.4, 0, .2, 0),
				Position = UDim2.new(.3, 0, .7, 0),
				ZIndex = 2, Parent = gui.gui,
				MouseButton1Click = function()
					if specGui then pcall(specGui) end
				end
			}
			Utilities.Write 'Cancel' {
				Frame = Utilities.Create 'Frame' {
					BackgroundTransparency = 1.0,
					Size = UDim2.new(0.0, 0, 0.5, 0),
					Position = UDim2.new(0.5, 0, 0.25, 0),
					ZIndex = 3, Parent = cancel.gui
				}, Scaled = true
			}
			specGui = function()
				specGui = nil
				spec1:remove()
				spec2:remove()
				cancel:remove()
				gui:remove()
			end
		end
	end


	return pvp end